---
- name: Selecting next service...
  set_fact:
    container_id: "{{ containers[index|int-1] }}"

- debug:
    msg: "Selected service: {{ container_id }}"

- name: Fetching configuration for container (native K8S)...
  include_vars: "{{ item }}"
  with_first_found: 
    - files: "{{ mode }}/k8s/{{ current_service_group.name }}/{{ container_id }}.yml"
      skip: true

- name: Fetching configuration for container (legacy CDH) ...
  include_vars: "{{ item }}"
  with_first_found: 
    - files: "{{ mode }}/docker/{{ current_service_group.name }}/{{ container_id }}.yml"
      skip: true

- name: "Validating configuration: (k8s_node)"
  fail:
    msg: "k8s_node needs to be defined and be one existing k8s cluster nodes when volumes are defined. See See https://confluence.devfactory.com/pages/viewpage.action?spaceKey=DE&title=Central+Kubernetes+User+Guide"
  when: k8s_node is not defined and service_volumes is defined
  tags: always

- name: "Validating configuration: k8s_service_visibility"
  fail:
    msg: "k8s_service_visibility needs to be defined when k8s_ingress_hosts are defined. See https://confluence.devfactory.com/pages/viewpage.action?spaceKey=DE&title=Central+Kubernetes+User+Guide"
  when: k8s_service_visibility is not defined and k8s_ingress_hosts is defined
  tags: always

- name: Defining container name...
  set_fact:
    container_name: "{{ stage }}_{{ project }}_{{ container_id }}"
    service_group: "{{ current_service_group.name }}"

- name: Defining container hostname (stage-project-container_id)
  set_fact:
    container_hostname: "{{ container_name | regex_replace('_','-') }}"
  when: container_hostname is not defined

- name: Cleaning up previous expansions...
  set_fact:
    published_ports: []
    published_volumes: []
    published_env_variables: {}
    published_labels: {}
    published_etc_hosts: {}
    published_networks: []
    published_log_options: {}
    published_dns_search_domains: []
    published_dns_servers: []
    published_volumes_from: []
    published_tmpfs: []
    published_configuration_files: {}
  tags: deploy

- name: Expanding ports...
  include_tasks: expand_ports.yml
  when: (global_ports | default([])) + (service_group_ports | default([])) + (service_ports | default([]))
  tags: deploy

- name: Changing volume paths to the ones for K8S
  set_fact:
    PROD_2_VOLUME_DIR: "/srv/docker_volumes/container_data1/{{ k8s_namespace }}"
    PROD_2_VOLUME_LOG_DIR: "/srv/docker_volumes/container_data1/{{ k8s_namespace }}"
    PROD_1_VOLUME_DIR: "/srv/docker_volumes/container_data1/{{ k8s_namespace }}"
    PROD_1_VOLUME_LOG_DIR: "/srv/docker_volumes/container_data1/{{ k8s_namespace }}"
    PROD_VOLUME_DIR: "/srv/docker_volumes/container_data1/{{ k8s_namespace }}"
    PROD_VOLUME_LOG_DIR: "/srv/docker_volumes/container_data1/{{ k8s_namespace }}"
    DEV_VOLUME_DIR: "/srv/docker_volumes/container_data1/{{ k8s_namespace }}"
    DEV_VOLUME_LOG_DIR: "/srv/docker_volumes/container_data1/{{ k8s_namespace }}"
    VOLUME_DIR: "/srv/docker_volumes/container_data1/{{ k8s_namespace }}"
    VOLUME_LOG_DIR: "/srv/docker_volumes/container_data1/{{ k8s_namespace }}"
  tags: deploy

- name: Expanding volumes...
  include_tasks: expand_volumes.yml
  when: (global_volumes | default([])) + (service_group_volumes | default([])) + (service_volumes | default([]))
  tags: deploy

- name: Expanding environment variables...
  include_tasks: expand_env_variables.yml
  when: (global_env_variables | default({})) + (service_group_env_variables | default({})) + (service_env_variables | default({}))
  tags: deploy

- name: Expanding hosts...
  include_tasks: expand_etc_hosts.yml
  when: (global_etc_hosts | default({})) + (service_group_etc_hosts | default({})) + (service_etc_hosts | default({}))
  tags: deploy

- name: Expanding labels ...
  include_tasks: expand_labels.yml
  when: (global_labels | default({})) + (service_group_labels | default({})) + (service_labels | default({}))
  tags: deploy

- name: Expanding networks ...
  include_tasks: expand_networks.yml
  when: (global_networks | default([])) + (service_group_networks | default([])) + (service_networks | default([]))
  tags: deploy

- name: Expanding log options...
  include_tasks: expand_log_options.yml
  when: (global_log_options | default({})) + (service_group_log_options | default({})) + (service_log_options | default({}))
  tags: deploy

- name: Expanding dns search domains ...
  include_tasks: expand_dns_search_domains.yml
  when: (global_dns_search_domains | default([])) + (service_group_dns_search_domains | default([])) + (service_dns_search_domains | default([]))
  tags: deploy

- name: Expanding dns servers ...
  include_tasks: expand_dns_servers.yml
  when: (global_dns_servers | default([])) + (service_group_dns_servers | default([])) + (service_dns_servers | default([]))
  tags: deploy

- name: Expanding volumes_from ...
  include_tasks: expand_volumes_from.yml
  when: (global_volumes_from | default([])) + (service_group_volumes_from | default([])) + (service_volumes_from | default([]))
  tags: deploy

- name: Expanding tmpfs ...
  include_tasks: expand_tmpfs.yml
  when: (global_tmpfs | default([])) + (service_group_tmpfs | default([])) + (service_tmpfs | default([]))
  tags: deploy
- debug:
    msg: "Image to pull: {{ container_base_image }}:{{ container_image_tag }}"

- name: Generate K8S ingress configuration file...
  template:
    src: ingress-config.j2
    dest: "{{ output_config_dir }}/{{ container_name }}-ingress.yml"
  register: ingress_configuration_output
  check_mode: no
  when: k8s_ingress_hosts is defined

- name: Generate K8S service configuration file...
  template:
    src: svc-config.j2
    dest: "{{ output_config_dir }}/{{ container_name }}-svc.yml"
  register: service_configuration_output
  check_mode: no
  when: k8s_ingress_hosts is defined

- name: Generate K8S service configuration file for smart-nat ...
  template:
    src: smart-nat-config.j2
    dest: "{{ output_config_dir }}/{{ container_name }}-svc.yml"
  register: smart_nat_configuration_output
  check_mode: no
  when: k8s_ingress_hosts is not defined and k8s_ip_private is defined

- name: Generate K8S pod configuration file (naked) ...
  template:
    src: pod-config.j2
    dest: "{{ output_config_dir }}/{{ container_name }}-pod.yml"
  when: k8s_pod_type == 'naked'
  register: pod_configuration_output
  check_mode: no

- name: Generate K8S pod configuration file (deployment) ...
  template:
    src: deployment-config.j2
    dest: "{{ output_config_dir }}/{{ container_name }}-pod.yml"
  when: k8s_pod_type == 'deployment'
  register: pod_configuration_output
  check_mode: no

- name: Removing existing Ingress object...
  shell: kubectl delete -f "{{ output_config_dir }}/{{ container_name }}-ingress.yml"
  ignore_errors: yes
  when: k8s_mode == 'cli' and k8s_ingress_hosts is defined

- name: Removing existing Service object...
  shell: kubectl delete -f "{{ output_config_dir }}/{{ container_name }}-svc.yml"
  ignore_errors: yes
  when: k8s_mode == 'cli' and ( not smart_nat_configuration_output|skipped or not service_configuration_output|skipped )

- name: Removing existing Pod object...
  shell: kubectl delete -f "{{ output_config_dir }}/{{ container_name }}-pod.yml"
  when: k8s_mode == 'cli' 
  ignore_errors: yes
  register: remove_existing_pod_cli

- name: Removing K8S ingress using API...
  kubernetes: 
      certificate_authority_data: "{{ k8s_certificate_authority_data }}"
      api_endpoint: "{{ k8s_api_endpoint }}"
      service_token: "{{ k8s_service_token }}"
      file_reference: "{{ output_config_dir }}/{{ container_name }}-ingress.yml"
      state: absent
  when: k8s_mode == 'api' and k8s_ingress_hosts is defined and k8s_update_strategy == 'replace'

- name: Removing K8S Service using API...
  kubernetes: 
      certificate_authority_data: "{{ k8s_certificate_authority_data }}"
      api_endpoint: "{{ k8s_api_endpoint }}"
      service_token: "{{ k8s_service_token }}"
      file_reference: "{{ output_config_dir }}/{{ container_name }}-svc.yml"
      state: absent
  when: k8s_mode == 'api'and k8s_update_strategy == 'replace'

- name: Removing K8S Pod using API...
  kubernetes: 
      certificate_authority_data: "{{ k8s_certificate_authority_data }}"
      api_endpoint: "{{ k8s_api_endpoint }}"
      service_token: "{{ k8s_service_token }}"
      file_reference: "{{ output_config_dir }}/{{ container_name }}-pod.yml"
      state: absent
  when: k8s_mode == 'api' and k8s_update_strategy == 'replace'
  register: remove_existing_pod_api

# pause in loops not works
# see: https://github.com/ansible/ansible-modules-core/issues/96
# solution is to replace module pause with module wait_for
# link: http://docs.ansible.com/ansible/latest/modules/wait_for_module.html

# Wait 25 secs because docker takes a while to remove resources (especially pods) when naked
#- name: Pausing for 25 seconds to allow resources to be deleted
#  pause:
#   prompt: "Waiting for resources to be deleted"
#   seconds: 25
#  when: k8s_pod_type == 'naked'

- name: Deploy K8S ingress using CLI...
  shell: kubectl create -f "{{ output_config_dir }}/{{ container_name }}-ingress.yml"
  when: k8s_mode == 'cli' and k8s_ingress_hosts is defined 

- name: Deploy K8S svc using CLI...
  shell: kubectl create -f "{{ output_config_dir }}/{{ container_name }}-svc.yml"
  when: k8s_mode == 'cli'  and ( not service_configuration_output|skipped or not smart_nat_configuration_output|skipped ) 

- name: Deploy K8S pod using CLI...
  shell: kubectl create -f "{{ output_config_dir }}/{{ container_name }}-pod.yml"
  when: k8s_mode == 'cli'

- name: Deploy K8S ingress using API...
  kubernetes: 
      certificate_authority_data: "{{ k8s_certificate_authority_data }}"
      api_endpoint: "{{ k8s_api_endpoint }}"
      service_token: "{{ k8s_service_token }}"
      file_reference: "{{ output_config_dir }}/{{ container_name }}-ingress.yml"
      state: present
  when: k8s_mode == 'api' and k8s_ingress_hosts is defined and k8s_update_strategy == 'replace'

- name: Deploy K8S svc using API...
  kubernetes: 
      certificate_authority_data: "{{ k8s_certificate_authority_data }}"
      api_endpoint: "{{ k8s_api_endpoint }}"
      service_token: "{{ k8s_service_token }}"
      file_reference: "{{ output_config_dir }}/{{ container_name }}-svc.yml"
      state: present
  when: k8s_mode == 'api' and k8s_update_strategy == 'replace'

- name: Deploy K8S pod using API...
  kubernetes: 
      certificate_authority_data: "{{ k8s_certificate_authority_data }}"
      api_endpoint: "{{ k8s_api_endpoint }}"
      service_token: "{{ k8s_service_token }}"
      file_reference: "{{ output_config_dir }}/{{ container_name }}-pod.yml"
      state: present
  when: k8s_mode == 'api' and k8s_update_strategy == 'replace'

- name: Update K8S ingress using API...
  kubernetes: 
      certificate_authority_data: "{{ k8s_certificate_authority_data }}"
      api_endpoint: "{{ k8s_api_endpoint }}"
      service_token: "{{ k8s_service_token }}"
      file_reference: "{{ output_config_dir }}/{{ container_name }}-ingress.yml"
      state: update
  when: k8s_mode == 'api' and k8s_ingress_hosts is defined and k8s_update_strategy == 'merge'

- name: Update K8S svc using API...
  kubernetes: 
      certificate_authority_data: "{{ k8s_certificate_authority_data }}"
      api_endpoint: "{{ k8s_api_endpoint }}"
      service_token: "{{ k8s_service_token }}"
      file_reference: "{{ output_config_dir }}/{{ container_name }}-svc.yml"
      state: update
  when: k8s_mode == 'api' and k8s_update_strategy == 'merge'

- name: Update K8S pod using API...
  kubernetes: 
      certificate_authority_data: "{{ k8s_certificate_authority_data }}"
      api_endpoint: "{{ k8s_api_endpoint }}"
      service_token: "{{ k8s_service_token }}"
      file_reference: "{{ output_config_dir }}/{{ container_name }}-pod.yml"
      state: update
  when: k8s_mode == 'api' and k8s_update_strategy == 'merge'

- name: Expanding configuration files...
  include_tasks: expand_configuration_files.yml
  when: (global_configuration_files | default({})) | combine (service_group_configuration_files | default({})) | combine (service_configuration_files | default({}))
  tags: deploy

- name: Configuring container...
  include_tasks: inject_configuration_file.yml
  with_dict: "{{ published_configuration_files }}"
  tags: deploy
