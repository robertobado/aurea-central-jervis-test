#!groovy
import org.yaml.snakeyaml.Yaml

/* 
TODO: 
1. Refactor code in steps section into a function to improve readability and maintenance 
2. Investigate why ANSIBLE_VAULT_PASSWORD is per stage and not global
*/

State.setContext(this)
notify = new Notify()

pipeline {
    environment {
        DEPLOYMENT_TARGET = getVariable('DEPLOYMENT_TARGET', 'docker')
        JERVIS_PLAYBOOK = 'aurea-central-jervis/ansible/jervis.yml'
    }
    agent {
        label 'stable && docker && linux && ansible'
    }
    stages {
        stage('Checkout SCM') {
            steps {
                // Default Git checkout done by Jervis is not compatible with aLine.
                // Please refer: https://jira.devfactory.com/browse/FIRE-14613
                checkout([$class: 'GitSCM', branches: [[name: env.BRANCH_NAME]], doGenerateSubmoduleConfigurations: false,
                extensions: [[$class: 'LocalBranch', localBranch: env.BRANCH_NAME]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'github-user-and-token', url: env.GIT_URL]]])

                withCredentials([usernamePassword(credentialsId: 'github-user-and-token', usernameVariable: 'USERID', passwordVariable: 'PASSWORD')]) {
                    sh 'git submodule add https://$USERID:$PASSWORD@github.com/trilogy-group/aurea-central-jervis.git'
                    sh 'git submodule update --init'
                }
            }
        }
        stage('Build Docker Image') {
                /* Do not build when branch is master or release */
                when {
                  expression {
                    return !("${GIT_BRANCH}" == 'master' || "${GIT_BRANCH}" == 'release')
                    }
                }
                environment {
                  ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                  unstash 'artifacts'
                  sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                  sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags docker-image-build --vault-password-file=.ansible-vault-password'
                }
        }
        stage('CDH Service Deploy') {
                when {
                    expression {
                        return ("$DEPLOYMENT_TARGET" == 'docker')
                    }
                }
                environment {
                  ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                  sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                  sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags docker-service-deploy --vault-password-file=.ansible-vault-password'
                }
        }
        stage('EC2 Service Deploy') {
                when {
                    expression {
                        return ("$DEPLOYMENT_TARGET" == 'ec2')
                    }
                }
                environment {
                    ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                    sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                    sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags ec2-instance,ec2-service-deploy --vault-password-file=.ansible-vault-password'
                }
        }
        stage('K8s Service Deploy') {
                when {
                    expression {
                        return ("$DEPLOYMENT_TARGET" == 'k8s')
                    }
                }
                environment {
                    ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                    sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                    sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags k8s-deploy --vault-password-file=.ansible-vault-password'
                }
        }
        stage('Health Checks') {
                /* Health Checks are run for all branches */
                environment {
                    ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                    sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                    sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags health-check --vault-password-file=.ansible-vault-password'
                }
        }
        stage('Smoke Tests') {
                /* Smoke test only runs when branch is qa or regression*/
                when {
                    expression {
                        return ("${GIT_BRANCH}" == 'qa' || "${GIT_BRANCH}" == 'regression')
                    }
                }
                environment {
                    ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                    sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                    sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags smoke-test --vault-password-file=.ansible-vault-password'
                }
        }
        stage('Regression Tests') {
                /* Regression test only runs when branch is qa or regression*/
                when {
                    expression {
                        return ("${GIT_BRANCH}" == 'qa' || "${GIT_BRANCH}" == 'regression')
                    }
                }
                environment {
                    ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                    sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                    sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags regression-test --vault-password-file=.ansible-vault-password'
                }
        }
        stage('Performance Tests') {
                /* Performance test only runs when branch is qa or regression*/
                when {
                    expression {
                        return ("${GIT_BRANCH}" == 'qa' || "${GIT_BRANCH}" == 'regression')
                    }
                }
                environment {
                    ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                    sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                    sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags performance-test --vault-password-file=.ansible-vault-password'
                }
        }
        stage('Load Tests') {
                /* Load test only runs when branch is qa or regression*/
                when {
                    expression {
                        return ("${GIT_BRANCH}" == 'qa' || "${GIT_BRANCH}" == 'regression')
                    }
                }
                environment {
                    ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                    sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                    sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags load-test --vault-password-file=.ansible-vault-password'
                }
        }
        stage('Security Tests') {
                /* Security test only runs when branch is qa or regression*/
                when {
                    expression {
                        return ("${GIT_BRANCH}" == 'qa' || "${GIT_BRANCH}" == 'regression')
                    }
                }
                environment {
                    ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                    sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                    sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags security-test --vault-password-file=.ansible-vault-password'
                }
        }
        stage('Promote Packages') {
                /* Promote Packages only runs when branch is release */
                when {
                    expression {
                        return ("${GIT_BRANCH}" == 'release')
                    }
                }
                environment {
                    ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                    sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                    sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags promote-packages --vault-password-file=.ansible-vault-password'
                }
        }
        stage('Send Notification') {
                /* Notifications are sent for all branches */
                environment {
                    ANSIBLE_VAULT_PASSWORD = credentials('ansible-vault-password')
                }
                steps {
                    sh 'echo "$ANSIBLE_VAULT_PASSWORD" > .ansible-vault-password'
                    sh 'ansible-playbook $JERVIS_PLAYBOOK -i ${INVENTORY_NAME} --tags send-notification --vault-password-file=.ansible-vault-password'
                }
        }
    }
    post {
        success {
            script {
                notify.send(env, currentBuild, 'success')
            }
        }
        failure {
            script {
                notify.send(env, currentBuild, 'failure')
            }
        }
        changed {
            script {
                notify.send(env, currentBuild, 'changed')
            }
        }
    }
}

class State {
    static Boolean loaded = false
    static Map<String, String> variables = [:]
    static def context = null
    static def setContext(_context) {
        context = _context
    }
    static def getContext() {
        return context
    }
    // Get parsed .jervis.yml
    static def getJervisYaml() {
        def jervisYaml = [:]

        def rawYaml = context.readFile file: '.jervis.yml', encoding: 'UTF-8'
        def yaml = new Yaml()
        jervisYaml = yaml.load(rawYaml)

        return jervisYaml
    }
}

/**
 * If Jenkins shows errors like
 * "Scripts not permitted to use new org.yaml.snakeyaml.Yaml"
 * Then you need to approve signatures on this page for local installation:
 * http://localhost:8080/scriptApproval/
 *
 * or for sandbox
 * http://jervis-sandbox2.devfactory.com/scriptApproval/
 */
def getVariable(String name, String defaultValue = '') {
    if (! State.loaded) {
        def list = State.getJervisYaml()
        def vars = list['variables'] ?: [:]
        vars.each{ variable ->
            def (key, value) = variable.tokenize('=')
            State.variables[key] = value
        }
        State.loaded = true
    }
    return State.variables[name] ?: defaultValue
}

class Notify {
    final String SUCCESS = 'SUCCESS'
    final String FAILURE = 'FAILURE'
    final String UNSTABLE = 'UNSTABLE'

    private rules = [:]
    private parsed = false

    def Notify() {
    }

    void parseRules() {
        if (this.parsed) {
            return
        }
        this.parsed = true
        def list = State.getJervisYaml()
        this.rules = list['notifications'] ?: [:]
    }

    def send(env, currentBuild, postMode) {
        this.parseRules()

        if (this.rules.size() == 0)
            return

        if (this.rules['slack']) {
            this.sendSlackMessage(env, currentBuild, postMode)
        }
        if (this.rules['email']) {
            this.sendEmailMessage(env, currentBuild, postMode)
        }
    }

    void sendSlackMessage(env, currentBuild, postMode) {
        def rules = this.rules['slack']['rooms']
        def context = State.getContext()

        rules.each { room ->
            def channel = room['channel']
            def onSuccess = room['on_success'] ?: 'never'
            def onFailure = room['on_failure'] ?: 'never'
            if (this.canSend(postMode, onSuccess, onFailure)) {
                this.sendSlack(env, currentBuild, channel)
            }
        }
    }

    void sendEmailMessage(env, currentBuild, postMode) {
        def rules = this.rules['email']['recipients']
        rules.each { item ->
            def recipients = item['to']
            def onSuccess = item['on_success'] ?: 'never'
            def onFailure = item['on_failure'] ?: 'never'
            if (this.canSend(postMode, onSuccess, onFailure)) {
                this.sendMail(env, currentBuild, recipients)
            } else {
                State.getContext().println "No email notification is sent: ${postMode}, ${onSuccess}, ${onFailure}"
            }
        }
    }

    boolean canSend(postMode, onSuccess, onFailure) {
        if (postMode == 'success') {
            if (onSuccess == 'always') {
                return true
            }
        } else if (postMode == 'failure') {
            if (onFailure == 'always') {
                return true
            }
        }
        return false
    }

    void sendSlack(env, currentBuild, channel) {
        def context = State.getContext()
        def result = currentBuild.currentResult
        def (domain, token, channelName) = channel.tokenize(':')
        def messageText = ''
        def color = 'good'

        if (result == SUCCESS) {
            messageText = "SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL}) [duration: ${currentBuild.durationString}]"
        } else if (result == FAILURE) {
            messageText = "FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL}) [duration: ${currentBuild.durationString}]"
            color = 'danger'
        } else {
            return
        }
        context.slackSend(teamDomain: domain,
                token: token,
                channel: channelName,
                color: color,
                message: messageText)
    }

    void sendMail(env, currentBuild, recipients) {
        def result = currentBuild.currentResult
        def bodyText = ''
        def titleText = ''
        def context = State.getContext()
        if (result == SUCCESS) {
            titleText = "SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'"
            bodyText = """SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]': Check console output at '${env.BUILD_URL}' [duration: ${currentBuild.durationString}]"""
        } else if (result == FAILURE) {
            titleText = "FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'"
            bodyText = """FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]': Check console output at '${env.BUILD_URL}' [duration: ${currentBuild.durationString}]"""
        } else {
            return
        }
        context.mail(to: recipients,
                mimeType: 'text/html',
                subject: titleText,
                body: bodyText
        )
    }
}
